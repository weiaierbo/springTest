{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"5298W","rootPoint":{"objectClass":"CGPoint","x":360,"y":1619},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"BESPE","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"1WN97","lineColorHex":"#DC306C","text":"循环依赖其实就是循环引用，也就是两个或者两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A"},"objectClass":"NSArray"},"text":" 概念"},"1":{"objectClass":"MindNode","ID":"25T7V","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"69B3U","lineColorHex":"#BF58F5","text":"检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。"},"objectClass":"NSArray"},"text":"怎么检测是否存在循环依赖"},"2":{"objectClass":"MindNode","ID":"82IW5","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"D91F3","lineColorHex":"#26BBFF","text":" Spring的循环依赖的理论依据基于Java的引用传递，当获得对象的引用时，对象的属性是可以延后设置的。（但是构造器必须是在获取引用之前）"},"1":{"objectClass":"MindNode","ID":"X2G60","lineColorHex":"#26BBFF","text":"Spring的单例对象的初始化主要分为三步： \n    ①：createBeanInstance：实例化，其实也就是 调用对象的构造方法实例化对象\n    ②：populateBean：填充属性，这一步主要是多bean的依赖属性进行填充\n    ③：initializeBean：调用spring xml中的init() 方法。\n循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。\n\n那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。\n\n/** Cache of singleton objects: bean name --> bean instance */\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);\n \n/** Cache of singleton factories: bean name --> ObjectFactory */\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);\n \n/** Cache of early singleton objects: bean name --> bean instance */\nprivate final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);\n\n这三级缓存分别指：\n\n singletonFactories ： 单例对象工厂的cache \n earlySingletonObjects ：提前暴光的单例对象的Cache 。【用于检测循环引用，与singletonFactories互斥】\n singletonObjects：单例对象的cache"},"2":{"objectClass":"MindNode","ID":"68CED","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"QF2BN","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"RO754","lineColorHex":"#26BBFF","text":""},"objectClass":"NSArray"},"text":"我们在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。主要调用方法就就是：\n\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return (singletonObject != NULL_OBJECT ? singletonObject : null);\n}\n上面的代码需要解释两个参数：\n\nisSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中，也就是没有初始化完成(比如A的构造器依赖了B对象所以得先去创建B对象， 或则在A的populateBean过程中依赖了B对象，得先去创建B对象，这时的A就是处于创建中的状态。)\nallowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象。\n分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则：\n\nthis.earlySingletonObjects.put(beanName, singletonObject);\n                        this.singletonFactories.remove(beanName);\n1\n2\n从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。\n\n从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory"},"objectClass":"NSArray"},"text":"三级缓存代码解析"},"objectClass":"NSArray"},"text":"Spring怎么解决循环依赖"},"3":{"objectClass":"MindNode","ID":"JDS9B","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"87E14","lineColorHex":"#37C45A","text":"https://blog.csdn.net/chejinqiang/article/details/80003868"},"1":{"objectClass":"MindNode","ID":"1C875","lineColorHex":"#37C45A","text":"https://blog.csdn.net/qq_36381855/article/details/79752689?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control"},"objectClass":"NSArray"},"text":"文档地址"},"4":{"objectClass":"MindNode","ID":"22122","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"GD12U","lineColorHex":"#1BD6E7","text":"其实二级缓存也能解决循环依赖问题，但是解决不了aop代理对象的问题，第三级缓存就是为了延迟创建代理对象，等初始化完成后再创建代理"},"objectClass":"NSArray"},"text":"为什么使用三级缓存"},"objectClass":"NSArray"},"text":"spring循环依赖"},"ID":"UW58D"}
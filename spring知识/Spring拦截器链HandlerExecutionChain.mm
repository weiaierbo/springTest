{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"MN3G4","rootPoint":{"objectClass":"CGPoint","x":360,"y":2020.5},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"QXW37","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"F5C63","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2SJ5C","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"6V230","lineColorHex":"#DC306C","text":"handlerAdapter调用handler方法之前执行该方法"},"objectClass":"NSArray"},"text":"preHandle方法"},"1":{"objectClass":"MindNode","ID":"QA3M3","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"A5D8P","lineColorHex":"#DC306C","text":"handlerAdapter调度handler方法之后，DispacterServlet渲染视图之前执行"},"objectClass":"NSArray"},"text":"postHandle方法"},"2":{"objectClass":"MindNode","ID":"35K4U","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"08KPI","lineColorHex":"#DC306C","text":"在渲染视图ViewResolver结束之后执行"},"objectClass":"NSArray"},"text":"afterCompletion方法"},"objectClass":"NSArray"},"text":"一组intercopters"},"1":{"objectClass":"MindNode","ID":"T4Z3H","lineColorHex":"#DC306C","text":"处理器handler"},"2":{"objectClass":"MindNode","ID":"YY8P1","lineColorHex":"#DC306C","text":"拦截器的下标intercopterIndex"},"objectClass":"NSArray"},"text":"构成"},"1":{"objectClass":"MindNode","ID":"E653O","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"364E0","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"I6RD3","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"U8Q28","lineColorHex":"#BF58F5","text":"boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tHandlerInterceptor[] interceptors = getInterceptors();\n\t\tif (!ObjectUtils.isEmpty(interceptors)) {\n\t\t\tfor (int i = 0; i < interceptors.length; i++) {\n\t\t\t\tHandlerInterceptor interceptor = interceptors[i];\n\t\t\t\tif (!interceptor.preHandle(request, response, this.handler)) {\n\t\t\t\t\ttriggerAfterCompletion(request, response, null);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.interceptorIndex = i;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"},"objectClass":"NSArray"},"text":"按照列表中interceptor的顺序来执行它们的preHandle方法，直到有一个返回false。再看一下返回false后这个方法所做的工作，这时会调用triggerAfterCompletion方法，此时this.interceptorIndex指向上一个返回true的interceptor的位置，所以它会按逆序执行所有返回true的interceptor的afterCompletion方法。"},"objectClass":"NSArray"},"text":"applyPreHandle"},"1":{"objectClass":"MindNode","ID":"Q3TU7","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"OCMJ3","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"6IXHR","lineColorHex":"#BF58F5","text":"void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception {\n\t\tHandlerInterceptor[] interceptors = getInterceptors();\n\t\tif (!ObjectUtils.isEmpty(interceptors)) {\n\t\t\tfor (int i = interceptors.length - 1; i >= 0; i--) {\n\t\t\t\tHandlerInterceptor interceptor = interceptors[i];\n\t\t\t\tinterceptor.postHandle(request, response, this.handler, mv);\n\t\t\t}\n\t\t}\n\t}"},"objectClass":"NSArray"},"text":"按照逆序执行所有interceptor的postHandle方法"},"objectClass":"NSArray"},"text":"applyPostHandle"},"2":{"objectClass":"MindNode","ID":"47G27","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"537O8","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"QB44M","lineColorHex":"#BF58F5","text":"/**\n\t * Trigger afterCompletion callbacks on the mapped HandlerInterceptors.\n\t * Will just invoke afterCompletion for all interceptors whose preHandle invocation\n\t * has successfully completed and returned true.\n\t */\n\tvoid triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)\n\t\t\tthrows Exception {\n\n\t\tHandlerInterceptor[] interceptors = getInterceptors();\n\t\tif (!ObjectUtils.isEmpty(interceptors)) {\n\t\t\tfor (int i = this.interceptorIndex; i >= 0; i--) {\n\t\t\t\tHandlerInterceptor interceptor = interceptors[i];\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterCompletion(request, response, this.handler, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tlogger.error(\"HandlerInterceptor.afterCompletion threw exception\", ex2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"},"objectClass":"NSArray"},"text":"从最后一次preHandle成功的interceptor处逆序执行afterCompletion方法"},"objectClass":"NSArray"},"text":"triggerAfterCompletion"},"objectClass":"NSArray"},"text":"主要方法"},"2":{"objectClass":"MindNode","ID":"6J78W","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"DF5C6","lineColorHex":"#26BBFF","text":"https://blog.csdn.net/qq_29373285/article/details/88564031"},"objectClass":"NSArray"},"text":"文档地址","url":"https://blog.csdn.net/qq_29373285/article/details/88564031"},"3":{"objectClass":"MindNode","ID":"61176","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"51D15","lineColorHex":"#37C45A","text":"假设我们有三个拦截器A,B,C,D，\n(1)针对所有拦截器preHandle都返回true的情况，在DispatcherServlet中分别依次调用HandlerExecutionChain类中applyPreHandle、applyPostHandle和triggerAfterCompletion方法。\n那么所有方法的执行顺序为：\n A.pre -> B.pre -> C.pre -> D.pre\n \n-> D.post -> C.post -> B.post -> A.post\n \n-> D.after -> C.after -> B.after -> A.after\n(2)针对有拦截器preHandle返回false的情况，不妨设C拦截器的preHandle返回为false,这时DispatcherServlet类调用HandlerExecutionChain类中applyPreHandle方法，然后由applyPreHandle调用triggerAfterCompletion方法，\n执行情况：\nA.pre -> B.pre -> C.pre -> \nB.after -> A.after，\n也就是，指向上一个返回true的interceptor的位置（B位置），所以它会按逆序执行所有返回true的interceptor的afterCompletion方法。（也就是跳过了他们的postHandle方法）"},"objectClass":"NSArray"},"text":"举例"},"4":{"objectClass":"MindNode","ID":"E6X15","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"64885","lineColorHex":"#1BD6E7","text":"// 先调用拦截器链的appliPreHandler\t\t\t\nif(!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n// Actually invoke the handler.\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n//调用拦截器链的applyPostHandle方法\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tdispatchException = ex;\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\t// As of 4.3, we're processing Errors thrown from handler methods as well,\n\t\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\n\t\t\t\tdispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n\t\t\t}\n//内部渲染视图，并在最后调用triggerAfterCompletion方法\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\t\tnew NestedServletException(\"Handler processing failed\", err));\n\t\t}"},"objectClass":"NSArray"},"text":"在DispatcherServlet中的调用"},"objectClass":"NSArray"},"text":"HandlerExecutionChain","remark":"spring\n--2020.12.28"},"ID":"C57J0"}